import java.util.Random;
import java.util.Scanner;
/*
Данный класс реализует игру "Угадай слово" из задания № 2:
2. * Создать массив из слов
String[] words = {"apple", "orange", "lemon", "banana", "apricot", "avocado", "broccoli", "carrot", "cherry", "garlic",
"grape", "melon", "leak", "kiwi", "mango", "mushroom", "nut", "olive", "pea", "peanut", "pear", "pepper", "pineapple",
"pumpkin", "potato"}.
При запуске программы компьютер загадывает слово, запрашивает ответ у пользователя, сравнивает его с загаданным словом и
 сообщает, правильно ли ответил пользователь. Если слово не угадано, компьютер показывает буквы, которые стоят на своих
 местах.
apple – загаданное
apricot - ответ игрока
ap############# (15 символов, чтобы пользователь не мог узнать длину слова)
Для сравнения двух слов посимвольно можно пользоваться:
String str = "apple";
char a = str.charAt(0); - метод, вернет char, который стоит в слове str на первой позиции
Играем до тех пор, пока игрок не отгадает слово.
Используем только маленькие буквы.
*/
public class GuessTheWords {
    // Создаем массив из загадываемых слов.
    private static String[] wordList = new String[] {"apple", "orange", "lemon", "banana", "apricot", "avocado",
            "broccoli", "carrot", "cherry", "garlic", "grape", "melon", "leak", "kiwi", "mango", "mushroom", "nut",
            "olive", "pea", "peanut", "pear", "pepper", "pineapple", "pumpkin", "potato", };
    private static String[] wordListCopy = new String[] {"apple", "orange", "lemon", "banana", "apricot", "avocado",
            "broccoli", "carrot", "cherry", "garlic", "grape", "melon", "leak", "kiwi", "mango", "mushroom", "nut",
            "olive", "pea", "peanut", "pear", "pepper", "pineapple", "pumpkin", "potato", };
    // Чтобы не загадывать одни и те же слова, их необходимо удалять из массива. Реализуем это с помощью сдвига значений
    // массива влево, начиная со слова, следующего за загаданным (оно будет копироваться на место загаданного и т.д.).
    // В следующую переменную будем сохранять новое значение "длины" массива и использовать ее, когда будет необходимо
    // определить длину массива, поскольку изменить непосредственно длину самого массива (чтобы использовать метод .length)
    // нельзя. Первоначально переменная для хранения длины массива инициализируется длинной массива и будет уменьшаться
    /// при удалении значений из массива в будущем.
    private static int wordListLength = wordList.length;
    // В следующую переменную будет сохраняться загаданное слово, которое должен отгадать пользователь в текущей игровой сессии.
    private static String bethoughtWord;
    // В следующую переменную записывается ввод пользователя, который может быть быть: (1) ответом пользователя на загадку,
    // который будет сравниваться со словом, загаданным в текущей игровой сессии для проверки угадал пользователь загаднное
    // слово или нет; (2) выбором пользователя касательно того закончить ли игру, начать ее сначала и т.д.
    private static String userInput;
    // Создаем объект класса scanner для считывания из консоли вводимых пользователем данных.
    private static Scanner scanner = new Scanner(System.in);
    // Создаем объект класса random для того, чтобы загадывать случайное слово из массива загадываемых слов.
    private static Random random = new Random();
    // В следующую переменную будем записывать подсказку для пользователя, в которой будут отображаться буквы из
    // введенного пользователем ответа, если они имеются в загаданном слове и стоят на том же по счету месте, что и в
    // ответе пользователя.
    private static char[] hint = new char[15];
    // Реализуем метод, который будет загадывать слова и проверять ответ пользователя.
    public static void startTheGame () {
        // Создаем бесконечный цикл, который будет загадывать слова до тех пор, пока они не кончатся, или пока пользователь
        // не решит прекратить игру.
        while (true) {
            // Определим место (индекс) слова в массиве загадываемых слов, которое загадываем в этот раз, и сохраним его.
            int index = random.nextInt(wordListLength);
            // Запишем слово, которое будет загадано в этот раз, в переменную, которая хранит загаданное в текущей игровой
            // сессии слово.
            bethoughtWord = wordList[index];
            // Теперь нам необходимо удалить загаданное слово из массива. Для этого просто циклично сдвинем значения
            // всего массива на место индекса загаданного слова.
            for (int i = index; i < wordListLength - 1; i++) {
                wordList[i] = wordList[i + 1];
            }
            // Запомним "новую длину" массива после "удаления" из него элемента, чтобы не было возможности обратиться к
            // словам, которые мы скопировали на место удаляемого слова.
            wordListLength--;
            // Вместо использованного выше способа "сокращения" длины массива можно было бы создать новый массив с
            // длиной, меньшей длины первоначального массива слов на единицу, затем скопировать в новый массив содержание
            // первоначального массива за исключением загаданного слова и присвоить переменной, хранящей ссылку на начальный
            // массив, ссылку на новый массив. В таком случае код бы выглядел, приблизительно, следующим образом:
            // if (wordList.length < 2) {byte gameOver = 1;}
            // if (wordList.length > 1)
            // {String[] wordListShorter = new String[wordList.length-1];
            // System.arraycopy(wordList, 0, wordListShorter, 0, index);
            // System.arraycopy(wordList, index+1, wordListShorter, index, wordListShorter.length - index);
            // wordList = wordListShorter;}
            // И в конце внешнего цикла:
            // if (gameOver == 1) {break;}
            // И нужно было бы решать проблему с тем, что при перезапуске игры потребовалось бы восстановить первоначальный
            // массив слов.
            System.out.println("Компьютер загадал слово на английском языке. Посмотрим, сможете ли Вы его отгадать.");
            // В каждой новой игровой сессии подсказка должна быть заполнена 15-ю элементами #. Восстановим значение "по
            // умолчанию" до того, как начинать загадывать новое слово.
            for (int i = 0; i < hint.length; i++) {
                hint[i] = '#';
            }
            // Следующий цикл загадывает пользователю слово, выбранное во внешнем цикле, до тех пор, пока пользователь его
            // не отагадает или решит начать игру заново / выйти из игры.
            while (true) {
                System.out.print("Введите Ваш ответ: ");
                userInput = scanner.nextLine();
                if (userInput.equals(bethoughtWord)) {
                    System.out.println("Вы угадали! Правильный ответ: " + bethoughtWord);
                    break;
                }
                // Если пользователь вместо отгадки введет 0, игра завершается, если 1, то загадывается новое слово и игра
                // начинается сначала.
                if (userInput.equals("0")) {
                    System.out.println("Вы вышли из игры. До встречи.");
                    for (int i = 0; i < wordList.length && i < wordListCopy.length; i++) {
                        wordList[i] = wordListCopy[i];
                    }
                    wordListLength = wordList.length;
                    return;
                }
                if (userInput.equals("1")) {
                    System.out.println("Сейчас компьютер попробует загадать новое слово.");
                    break;
                }
                // Если пользователь не угадал загаданное слово, необходимо вывести ему подсказку, которая формируется
                // в следующем цикле посредством посимвольного сопоставления ответа пользователя и загаданного слова.
                for (int i = 0; i < bethoughtWord.length() && i < userInput.length(); i++) {
                    if (userInput.charAt(i) == bethoughtWord.charAt(i)) {
                        hint[i] = bethoughtWord.charAt(i);
                    }
                }
                System.out.println("К сожалению, ответ неверный. Попробуйте еще раз. Для выхода из игры введите 0, чтобы " +
                        "загадать другое слово введите 1.");
                System.out.println("Даю подсказку. Вы угадали следующие буквы и их место в слове: "
                        + printCharArray(hint));
            }
            //Если слова, которые можно загадать, закончились, игра прекращается.
            if (wordListLength < 1) {
                System.out.println("Все слова разгаданы! Игра окончена.");
                for (int i = 0; i < wordList.length && i < wordListCopy.length; i++) {
                    wordList[i] = wordListCopy[i];
                }
                wordListLength = wordList.length;
                break;
            }
            // Проверим не ввел ли пользователь во время игры цифру "1", что означало бы, что пользователь решил
            // запустить игру заново - в таком случае нет необходимости спрашивать у пользователя еще раз хочет ли он
            // запустить игру сначала. Вместо этого можно было бы внешнему циклу присвоить метку (например, outer) и внутри цикла
            // загадывания слова предусмотреть инструкцию continue outer. Однако в этом случае проверку на количество
            // сыгранных игр потребовалось бы перенести в начало внешнего цикла и тогда мы бы заходили в цикл лишний раз,
            // только чтобы его прекратить без выполнения.
            if (userInput.equals("1")){continue;}
            // Спросим пользователя хочет ли он сыграть снова. Если ответ будет "да" (1), то цикл запустится заново без
            // каких-либо дополнительных инструкций и проверок.
            System.out.println("Сыграем еще раз?");
            userInput = askYesNo();
            if (userInput.equals("0")) {
                System.out.println("Жаль. В таком случае увидимся в другой раз!");
                for (int i = 0; i < wordList.length && i < wordListCopy.length; i++) {
                    wordList[i] = wordListCopy[i];
                }
                wordListLength = wordList.length;
                break;
            }
        }
    }
    // Реализуем метод, который будет просить пользователя сделать выбор между "да" и "нет" и проверять корректность
    // введенного пользователем ответа.
    private static String askYesNo() {
        String input;
        while (true) {
            System.out.println("Введите: 1, если \"да\", или 0, если \"нет\".");
            input = scanner.nextLine();
            if (!input.equals("1") && !input.equals("0")) {
                System.out.println("Вы ввели недопустимое значение. Попробуйте еще раз.");
            } else {
                break;
            }
        }
        return input;
    }
    // Реализуем метод, который будет преобразовывать массив из символов, являющийся подсказкой пользователю загаданного
    // слова, в строку для его последующего отображения пользователю.
    private static String printCharArray(char[] printingArray){
        String result = "";
        for (char c : printingArray) {
            result = result + " " + c;
        }
        return result;
    }
}
